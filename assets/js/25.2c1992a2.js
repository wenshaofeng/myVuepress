(window.webpackJsonp=window.webpackJsonp||[]).push([[25],{285:function(t,s,e){"use strict";e.r(s);var a=e(28),n=Object(a.a)({},(function(){var t=this,s=t.$createElement,e=t._self._c||s;return e("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[e("h1",{attrs:{id:"git-数据恢复"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#git-数据恢复"}},[t._v("#")]),t._v(" git 数据恢复")]),t._v(" "),e("p",[t._v("记住，任何已经提交到 Git 的都可以被恢复。即便在已经删除的分支中的提交，或者用 --amend 重新改写的提交，都可以被恢复（关于数据恢复的内容见第九章）。所以，你可能失去的数据，仅限于没有提交过的，对 Git 来说它们就像从未存在过一样。")]),t._v(" "),e("h2",{attrs:{id:"清理"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#清理"}},[t._v("#")]),t._v(" 清理")]),t._v(" "),e("p",[t._v("Git 会保留从项目最开始保留所有的数据，当一个代码仓库长期使用后，会发现代码仓库越来越大，分支也越来越多；这些都会影响到我们 Git 仓库的速度，如果发现一些分支不需要了，我们可以手动删除，以此提高响应速度；\n一般两类分支可能需要清理：")]),t._v(" "),e("ol",[e("li",[t._v("本地不存在，远程存在该分支，但不需要了")]),t._v(" "),e("li",[t._v("远程不存在，本地存在该分支，也不需要了")])]),t._v(" "),e("ul",[e("li",[t._v("清理远程")])]),t._v(" "),e("div",{staticClass:"language- line-numbers-mode"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("git push origin --delete <远程分支名>\n")])]),t._v(" "),e("div",{staticClass:"line-numbers-wrapper"},[e("span",{staticClass:"line-number"},[t._v("1")]),e("br")])]),e("ul",[e("li",[t._v("清理本地")])]),t._v(" "),e("h3",{attrs:{id:"忽略已加入版本控制器的文件和文件夹"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#忽略已加入版本控制器的文件和文件夹"}},[t._v("#")]),t._v(" 忽略已加入版本控制器的文件和文件夹")]),t._v(" "),e("p",[t._v("有的时候，可能一不小心把某一个原本应该忽略的目录提交到了版本控制器中，再使用 .gitignore 文件去忽略的时候，发现无论如何都无法再次将其忽略，只好默默忍受；这是因为 git 已经索引了该文件而导致的")]),t._v(" "),e("ul",[e("li",[t._v("问题复现")])]),t._v(" "),e("blockquote",[e("ol",[e("li",[t._v("创建了一个本想忽略的文件a，提交到了版本库")]),t._v(" "),e("li",[t._v("在.gitignore 设置规则忽略后，发现不生效")])])]),t._v(" "),e("ul",[e("li",[t._v("解决")])]),t._v(" "),e("div",{staticClass:"language-bash line-numbers-mode"},[e("pre",{pre:!0,attrs:{class:"language-bash"}},[e("code",[t._v("// 忽略文件\n"),e("span",{pre:!0,attrs:{class:"token function"}},[t._v("git")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token function"}},[t._v("rm")]),t._v(" --cached "),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v("<")]),t._v("文件名"),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v(">")]),t._v("\n\n// 忽略文件夹\n\n//删除该文件夹的缓存\n"),e("span",{pre:!0,attrs:{class:"token function"}},[t._v("git")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token function"}},[t._v("rm")]),t._v(" -r --cached test3/\n// 强制添加\n"),e("span",{pre:!0,attrs:{class:"token function"}},[t._v("git")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token function"}},[t._v("add")]),t._v(" -f test3\n")])]),t._v(" "),e("div",{staticClass:"line-numbers-wrapper"},[e("span",{staticClass:"line-number"},[t._v("1")]),e("br"),e("span",{staticClass:"line-number"},[t._v("2")]),e("br"),e("span",{staticClass:"line-number"},[t._v("3")]),e("br"),e("span",{staticClass:"line-number"},[t._v("4")]),e("br"),e("span",{staticClass:"line-number"},[t._v("5")]),e("br"),e("span",{staticClass:"line-number"},[t._v("6")]),e("br"),e("span",{staticClass:"line-number"},[t._v("7")]),e("br"),e("span",{staticClass:"line-number"},[t._v("8")]),e("br"),e("span",{staticClass:"line-number"},[t._v("9")]),e("br")])]),e("p",[t._v("忽略已存在的文件夹最后一步需要使用 -f 进行强制添加，否则会提示操作失败")]),t._v(" "),e("h2",{attrs:{id:"恢复"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#恢复"}},[t._v("#")]),t._v(" 恢复")]),t._v(" "),e("h3",{attrs:{id:"git-reflog"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#git-reflog"}},[t._v("#")]),t._v(" "),e("code",[t._v("git reflog")])]),t._v(" "),e("p",[t._v("一般情况下，除非手动执行了 "),e("code",[t._v("git gc")]),t._v(" 命令，否则 gc 对那些无用的 object 会保留很长时间后才清除的，"),e("code",[t._v("reflog")]),t._v(" 是 Git 提供的一个内部工具，用于记录对 Git 仓库进行的各种操作，可以使用 "),e("code",[t._v("git reflog show")]),t._v(" 所有的管理类操作日志。")]),t._v(" "),e("ul",[e("li",[e("p",[t._v("回滚 reset 操作\n不小心用 "),e("code",[t._v("git reset")]),t._v(" 回滚了提交记录，想找回之前的提交记录: git reflog 查看操作历史，找到执行 git reset 命令之前 commitid，然后 git reset --hard 到那个 commitid 即可。")])]),t._v(" "),e("li",[e("p",[t._v("从历史版本中找回删除的文件")])])]),t._v(" "),e("p",[t._v("有时候，我们在某个版本中删除了文件，后来又突然发现需要这个文件，也是可以恢复的；恢复之前首先确定要恢复的文件在哪一个版本（commit）中，假设那个版本号是： 7a4312sd，文件路径为 abc.php 那么参考命如下：")]),t._v(" "),e("div",{staticClass:"language- line-numbers-mode"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("git checkout 7a4312sd abc.php\n")])]),t._v(" "),e("div",{staticClass:"line-numbers-wrapper"},[e("span",{staticClass:"line-number"},[t._v("1")]),e("br")])]),e("h3",{attrs:{id:"git-reset"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#git-reset"}},[t._v("#")]),t._v(" "),e("code",[t._v("git reset")])]),t._v(" "),e("ol",[e("li",[t._v("之前的修改进行了 "),e("code",[t._v("commit")]),t._v(" 提交，也就是说我们回退前的修改（曾经）存在于版本里;")]),t._v(" "),e("li",[t._v("之前的修改未进行 "),e("code",[t._v("commit")]),t._v(" 提交，但是进行了 "),e("code",[t._v("git add")]),t._v("操作；")]),t._v(" "),e("li",[t._v("之前的修改未进行 "),e("code",[t._v("commit")]),t._v(" 提交，也未进行"),e("code",[t._v("git add")]),t._v("操作。")])]),t._v(" "),e("div",{staticClass:"language-shell line-numbers-mode"},[e("pre",{pre:!0,attrs:{class:"language-shell"}},[e("code",[t._v("// 第一种\n\n"),e("span",{pre:!0,attrs:{class:"token comment"}},[t._v("## 拿到之前修改的commit的哈希值（或者说id）")]),t._v("\n"),e("span",{pre:!0,attrs:{class:"token function"}},[t._v("git")]),t._v(" reflog \n"),e("span",{pre:!0,attrs:{class:"token function"}},[t._v("git")]),t._v(" reset --hard "),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("[")]),t._v("hash"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("]")]),t._v("\n\n// 第二种\n\n"),e("span",{pre:!0,attrs:{class:"token comment"}},[t._v("## 添加到缓存之后进行了reset操作， 此时因为没有进行git commit操作所以没有hash值，")]),t._v("\n"),e("span",{pre:!0,attrs:{class:"token function"}},[t._v("git")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token function"}},[t._v("fsck")]),t._v(" --lost-found\n\n// 第三种\n暂无\n")])]),t._v(" "),e("div",{staticClass:"line-numbers-wrapper"},[e("span",{staticClass:"line-number"},[t._v("1")]),e("br"),e("span",{staticClass:"line-number"},[t._v("2")]),e("br"),e("span",{staticClass:"line-number"},[t._v("3")]),e("br"),e("span",{staticClass:"line-number"},[t._v("4")]),e("br"),e("span",{staticClass:"line-number"},[t._v("5")]),e("br"),e("span",{staticClass:"line-number"},[t._v("6")]),e("br"),e("span",{staticClass:"line-number"},[t._v("7")]),e("br"),e("span",{staticClass:"line-number"},[t._v("8")]),e("br"),e("span",{staticClass:"line-number"},[t._v("9")]),e("br"),e("span",{staticClass:"line-number"},[t._v("10")]),e("br"),e("span",{staticClass:"line-number"},[t._v("11")]),e("br"),e("span",{staticClass:"line-number"},[t._v("12")]),e("br"),e("span",{staticClass:"line-number"},[t._v("13")]),e("br")])]),e("h4",{attrs:{id:"git-reset-参数"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#git-reset-参数"}},[t._v("#")]),t._v(" git reset 参数")]),t._v(" "),e("p",[t._v("git reset 分为三种：软 --soft，中 ---mixed，硬 --hard 对应着三种回滚的程度，程度越硬，回滚的越“狠”")]),t._v(" "),e("blockquote",[e("ol",[e("li",[t._v("--soft 已 add，但尚未 commit")]),t._v(" "),e("li",[t._v("--mixed（git reset 的默认设定，可以省略不写），文件会回退到未 add（未暂存）的状态")]),t._v(" "),e("li",[t._v("--hard 硬核，彻底，会彻底返回到回退前的版本状态，了无痕迹")])])]),t._v(" "),e("h3",{attrs:{id:"git-revert-单独回滚代码：记录不变只回滚代码"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#git-revert-单独回滚代码：记录不变只回滚代码"}},[t._v("#")]),t._v(" "),e("code",[t._v("git revert")]),t._v(" 单独回滚代码：记录不变只回滚代码")]),t._v(" "),e("div",{staticClass:"language- line-numbers-mode"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("git revert <要回滚的commit的hash>\n")])]),t._v(" "),e("div",{staticClass:"line-numbers-wrapper"},[e("span",{staticClass:"line-number"},[t._v("1")]),e("br")])]),e("blockquote",[e("p",[t._v("需要注意的是，在使用 "),e("code",[t._v("revert")]),t._v(" 去恢复某个版本代码时，Git 只会撤销指定版本的代码，而不是指定版本后的所有版本。比如说你提交了 1、2、3 三个版本，当你撤销版本 2 的时候，会生成版本 4，但是不会对版本 3 产生影响。")])]),t._v(" "),e("ol",[e("li",[e("code",[t._v("git reset")]),t._v(" 命令会改变之前的版本记录，可能会导致不能提交到远程仓库（设置了权限之类的）；")]),t._v(" "),e("li",[e("code",[t._v("git revert")]),t._v(" 命令只会撤销某个版本的代码，然后在当前分支增加一条版本新记录；")]),t._v(" "),e("li",[e("code",[t._v("git revert")]),t._v(" 只会撤销指定版本的代码，而不是指定版本后的所有版本。")])])])}),[],!1,null,null,null);s.default=n.exports}}]);